<12/26>
1. 식별자 : 어떤 ‘값’을 구별해서 식별할 수 있는 이름  (변수, 함수, 클래스 등의 이름)
	          => 값이 아니라 메모리 주소를 기억하고 있음

2. 값 : 표현식이 평가되어 생성된 ‘결과’


3. 표현식 : 값으로 평가될 수 있는 문
   => js의 모든 문은 표현식인 문과 표현식이 아닌 문으로 나뉜다.(해당 문을 변수에 할당할 수 있는가로 판단 가능)

   ex) 
      함수 선언문 =>  표현식이 아닌 문
      함수 리터럴, 함수 표현식 => 표현식인 문 

4. 토큰 : 문법적으로 더이상 나눌 수 없는 코드의 기본 요소  
    
5.  암묵적 형변환 시 falsy한 값들
	1) ‘’ : 빈문자열
        2) 0,-0  
        3) undefined
	4) null    : null의 typeof는 object이다
        5) NaN
        6) false
		

6.  js에서  var 변수는 선언 시 undefined로 초기화 
    선언과 동시에 값을 할당한다고 그 값으로 초기화 되는 것이 아니다
    
   let변수는 선언과 초기화가 나누어져 있음
    => 초기화 하기 전까지 참조불가 => TDZ(temporal dead zone)
     //따라서 호이스팅이 안되는 것처럼 보이지만 사실 되긴 함
      하여튼 초기화 전에 참조 불가
	
     +++ let, const로 선언한 전역 변수는 전역객체의 프로퍼티가 아님 (window.변수이름으로 접근x)
         var 혹은 암묵전 전역으로 선언한 변수, 전역으로 선언한 선언적 함수는 전역객체의 프로퍼티o 


7. 원시 데이터 타입으로 값이 할당된 변수에 값을 변경할 경우, 기존 메모리 공간이 아닌
      새로운 메모리 공간에 변경한 값을 생성해 보관


8. 객체 리터럴의 중괄호는 코드블럭이 아니다 => ; 붙이기 추천 


*9. 코드가 어디서 실행되고 주변에 어떤 코드가 있는가? : 렉시컬 스코프
    => 실행컨텍스트와의 차이는?? (23장 읽은 후  다시 생각해보기)

10. 스코프체인 : 스코프의 계층적 연결(변수를 참조할 때 상위 스코프 방향으로 이동하며 찾는다)
	     // 상속에서 자식은 부모의 자원을 사용할 수 있지만 부모가 자식의 자원을 사용할 수 없듯이
             // 상위 스코프에서 하위 스코프에서만 유효한 변수를 참조하는 경우는 없다 


11. 호이스팅은 런타임이 시작되기 이전에 식별자의 선언 및 초기화가 미리 실행되기 때문에 발생한다
      => 그래서 끌어 올려진 것처럼 보이는 것
        //**호이스팅 또한 스코프 단위로 동작한다
        스코프의 선두로 끌어 올려지는 것처럼 동작한다고 생각하면 될듯

12. 정적스코프와 동적스코프

    - 렉시컬 스코프 : 정적 스코프(함수를 어디서 선언했느냐에 따라 상위 스코프를 결정)
	                =>js는 렉시컬 스코프를 따른다.

    - 동적 스코프 : 함수를 어디서 호출했느냐에 따라 상위 스코프를 결정



13. 전역 객체 : 코드가 실행되기 이전 어떤 객체보다 제일 먼저 생성되는 객체    
             =>   브라우저 환경 : window       
                  node.js환경 : global

                    

14. 프로퍼티 어트리뷰트 :

 js는 프로퍼티를 생성할 때 프로퍼티의(객체의 키) '상태'를 나타내는 프로퍼티 어트리뷰트를 자동 정의함

  내부슬롯 => [[Value]], [[Writable]], [[Enumerable]](열거할 수 있는가?) , [[configurable]] 등으로 나타남 
        =>Object.getOwnPropertyDescriptor(객체의 참조 , 프로퍼티키의 문자열) 형식으로 조회 가능
          Object.defineProperty(객체의 참조, 프로퍼티의 문자열, 프로퍼티 디스크립터객체)를 통해 재정의 가능
          (여러 개면 .defineProperties 사용)


    - 크게 데이터 프로퍼티와 접근자 프로퍼티로 나뉨
	데이터 프로퍼티 : 자체적으로 값을 가지는 프로퍼티
	접근자 프로퍼티 : 자체적으로 값x, 다른 데이터프로퍼티의 값을 읽거나 저장

    - 데이터프로퍼티의 configurable이 flase일 경우 객체.프로퍼티명의 형태로는 수정이 불가능하고   
      대신 접근자 프로퍼티로 설정한 setter에 의해서는 수정 가능
      => 자바의 클래스와 Praive 접근제어자와  비슷한 느낌인걸까??

    - 수정이 안되게 얼리는 방법도 많음 
       1) Object.preventExtenstions(객체의 참조) => 프로퍼티 추가 방지
       2) Object.seal(객체의 참조) => 프로퍼티의 삭제 방지
       3) Object.freeze(객체의 참조) => 프로퍼티의 수정까지 방지 => 하지만 중첩된 객체까지 영향x
       //따라서 불변객체를 위해선 재귀적으로 Object.freeze를 호출해야 함      
       //(.key 메서드를 통해 프로퍼티를 배열로 만들고 .forEach를 통해 .freeze를 걸어버리는듯)

  
15. 생성자 함수 : new 함수이름(); 형태

 - new가 없으면 생성자의 역할을 하지 x   
  => new 가 있으면 내부메서드[[Construct]] 호출        
      ‘’    없으면 내부메서드[[Call]] 호출

 - 함수에서 return으로 반환하지 않더라도 
   new 키워드와 함께 사용하면 암묵적으로 인스턴스를 생성 후 this에 바인딩 
    => 런타임 이전에 빈 객체로 생성해서 선언된다.
      '생성자 함수가 실행될 때 인스턴스 초기화 및 할당'


16. 함수는 일급객체 

  - 무명의 리터럴로 생성 가능한가? => 런타임에 생성이 가능한가?
  - 변수나 자료구조에 저장이 가능한가? 
  - 함수의 매개변수로 전달 가능한가? 
  - 함수의 반환값으로 사용 가능한가? 
  
  함수는 모든 조건을 부합:     
  따라서 함수도 객체 프로퍼티를 갖는다=> length, name, argumens, caller, prototype 등 

       
  함수호출 시 매개변수의 개수가 자유로운 특성 때문에 
  'argument 프로퍼티'와 'Rest파라미터'를 사용해 전달받은 인수의 개수에 따라 다르게 동작하게 하는 방법이 자주 쓰임 
       
  *Rest 파라미터란  : (… 매개변수)의 형태로 
   매개변수 중 제일 마지막에 오며   
   앞에 선언된 매개변수들을 제외한 나머지 매개변수를 배열에 담아 할당한다 => 배열의 메서드 사용 가능   


<12/27>

17. 모든 객체는 [[Prototype]]이라는 내부슬롯을 가짐 => 객체의 생성방식에 따라 결정
     1)객체 리터럴에 의한 생성 => Object.prototype
     2)생성자 함수에 의한 생성 => 생성자함수의 prototype에 바인딩 되어 있는 객체

18. [[Prototye]] 내부슬롯에는 직접 접근 불가 
	=> 무분별하게 프로토타입 교체해 순환 참조와 같은 현상을 방지하기 위해
           (프로토타입체인의 단방향을 지키기 위해)

     (과거)
     .__proto__를 통해서 접근[[Get]],
     .__proto__ = 프로토타입으로 지정할 객체이름 (할당을 하면) 형태를 통해 지정[[Set]]
     

     (현재) //모든 객체가 _proto__를 사용할 수 있는 것이 아님 
           //(Object.protoype을 상속받지 않는 경우가 간혹가다 있을 수도)

      ==> 따라서 최근에는 .getPrototypeOf(프로토타입을 알아볼 객체이름)
	              .setPrototypeOf(프로토타입을 지정할 객체이름, 프로토타입으로 지정할 객체 이름)


19.생성자 함수객체는'prototype'이라는 프로퍼티 소유(내부슬롯 [[Prototype]]과 헷갈리지 않기)
        일반객체는 'prototype'프로퍼티 소유x


	* [[Prototype]] 개별객체의 속성 // .__proto__ 혹은 Object.getPrototypeOf()으로 접근
          .prototype   생성자의 속성   

         =>  Object.getPrototypeOf(new Foobar()) === Foobar.prototype



**(다시보기)20. 리터럴로 생성한 객체나 함수는 Object 생성자 함수나 Function 생성자 함수가 아니다.(구체적인 생성 방식이 다른듯)
							                       //생성과정과 스코프 클로저 등의 차이가 있음
    ==> 그런데 .constructor 를 통해 확인하면  Object생성자함수, Function생성자 함수라고 뜸
									       //기존 객체나 함수로서의 동일한 특성을 가짐
      ==> 내부동작에 의해 가상적인 생성자 함수를 갖는다(OrdinayObjectCreate라는 거에 의해 생성된다 함)

  	  //프로토타입과 생성자 함수는 반드시 쌍으로 존재해야 함

21. 따라서 모든 프로토타입은 생성자함수가 생성되는 시점에 동시에 생성된다
    - 빌트인 함수들의 생성자 ex) (Object, String, Number, Promise, Function 등 //Math는 해당x) 
      역시 생성될 때 그들의 프로토타입이 생성된다.
       => 빌트인 생성자 함수는 전역객체가 생성될 때 생성
       ==> 빌트인 생성자 함수의 프로토타입도 그래서 전역객체가 생성될 때 생성되어 빌트인 생성자 함수의 prototype프로퍼티에 바인딩된다

********
22. 위에서 아무리 어려운 소리를 해도 결국 중요한건
    모든 객체는 OrdinayObjectCreate라는 추상 연산에 의해 프로토타입이 결정되고 생성되며(최상위 Object.prototype은 null임)
    프로토타입과 프로토타입 체인이 존재함에 따라 상속을 구현할 수 있었고 코드의 재사용성을 높일 수 있었다

    함수의 경우 'prototype'이라는 프로퍼티에 의해
    객체의 경우 [[Prototype]]이라는 내부슬롯에  해당 프로토타입이 바인딩 되어있다.


24.js의 경우  프로토타입 메서드를 인스턴스에서 재정의(overriding)할 때 이를 프로퍼티 섀도잉이라고 함

25. 생성자 함수를 통해 객체를 만들고 난 뒤,
    객체 리터럴을 통해 생성자 함수의 프로토타입을 변경했을 경우
    객체 리터럴은 constructor라는 프로퍼티가 없으므로(따로 지정해주지 않았을 때)
    인스턴스의 생성자를 검색하면 Object.prototype이 나온다(체이닝을 타고 올라가서)

26. (25번 연장)당연한 이야기지만 생성자 함수에서 .prototype을 통해 프로토타입을 교체하는 건 말 그대로 교체이고
    인스턴스에서.setPrototypeOf()를 통해 프로토타입을 교체하는 건 기존 생성자 함수와의 관계를 끊는 일이다.
    근데 또 constructor:기존 생성자함수 이름, 처럼 프로퍼티에 직접 접근해서 다시 연결해줄 수도 있긴한데
    => 직접 교체하는 게 좋은 습관은 아니라고 함 (직접 상속이 더 편리하고 안전)
					Object.create(프로토타입으로 지정할 객체, ...)


<12/28>

27. 객체 식별자 instanceOf 생성자함수 
     좌항의 객체가 우항의 인스턴스인지(의해서 만들어졌는지) 검사
     *우측 생성자 함수의 prototype에 바인딩된 객체가 좌변의 프로토타입 체인 상에 존재하는가?
       (constructor를 기준으로 검색이 아니다)

28.정적 프로퍼티/메서드 (static)은 상속x 
   생성자 함수에서 선언된 정적 프로퍼티와 메서드는 생성된 인스턴스에서는 참조 및 호출 불가


29. key in object : object 안에 key이름의 프로퍼티가 존재하는가?
		  *(object의 프로토타입 체인상에 key이름의 프로퍼티가 존재하는가?)

  - Reflect.has(object, key) 도 동일한 역할

30. 객체에서의 for ... in 문
    => 단순 순회가 아니라 상속받은 프로퍼티도 열거한다고함
	**단, 정확히 말하면 프로퍼티 어트리뷰트에 [[Enumerable]]이 false인게 안 나오는듯
 	++ 심볼인 프로퍼티노 열거x

    따라서 본인이 가진 프로퍼티를 열거하려면 
     1) 조건으로 hasOwnProperty()를 사용하거나 
     2) Object.Keys(object)를 사용하는 것이 편하다 


<12/29>

31. 래퍼객체 : 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 '임시객체'
               => 원시타입의 데이터에도 연관 객체의 메서드를 사용기 위해

             const str= 'hi';
             clg(str.length); //str을 래퍼객체 String의 인스턴스로 변환 후 메서드 사용(이후 래퍼객체는 가비지 콜렉션 대상)
             clg(typeof str); //String이 나옴( 다시 원시 값으로 되돌림)
                              //str을 new String()을 통해 생성했으면 object가 나왔을 터


<12/31>

32. 암묵적 전역 : 선언하지 않은 식별자에 값을 할당하면 전역객체의 프로퍼티가 된다
               ex) y=20   //window.y = 20;
        	전역변수처럼 동작하지만 사실 프로퍼티이니 호이스팅 발생x 
                +delete 식별자로 삭제 가능



33.실행 컨텍스트 : 코드를 실행하는 데에 필요한 환경 제공 및 결과를 관리하는 영역
                (식별자를 등록하고 관리하는 스코프와 // 코드 실행 순서 관리를 구현한 내부 메커니즘)
                 실행컨텍스트의 렉시컬 환경             실행컨텍스트 스택


               크게 4가지 타입의 소스코드를 평가 후 실행 컨텍스트를 생성한다.
               1) 전역 코드 
               2) 함수 코드 
               3) eval 코드  
               4) 모듈 코드 


34. JS는 소스 코드의 평가와 소스 코드의 실행 과정으로 나누어서 처리함
    1) 소스코드를 평가하는 과정에서 선언된 식별자들(선언문)을 실행 컨텍스트가 관리하는 스코프에 등록 후 undefined로 초기화
    2) 소스코드가 실행되면서 이전에 실행된 선언문들을 제외하고 실행 (ex) 할당문 실행)
    3) 할당하려는 식별자가 선언 되어있는지 실행컨텍스트의 스코프에서 확인
    4) 선언되어 있다면 값을 할당 후 결과를 다시 실행컨텍스트의 스코프에 등록


35. 위의 과정이 반복적으로 굴러간다.
    <1> 전역코드 평가
    <2> 전역코드 실행
    <3> 함수코드 평가(함수 호출 시 전역 코드 실행 일시 정지//코드의 제어권이 호출된 함수 내부로 이동)
    <4> 함수코드 실행
    ...

   과 같은 순서로 실행되기 떄문에 스코프, 식별자,(+상태변화) 코드 실행 순서 등의 관리가 필요
   => 스코프 체인, 프로토타입 체인 등을 이용해 식별자를 검색 및 관리 
      +함수 호출 종료시 호출 이전 실행한 코드와 이후 실행할 코드 구분 등이 필요한데
      ==> 이를 실행 컨텍스트의 렉시컬환경과 스택으로 구현하고 있다는 것이 핵심


36. 생성된 실행 컨택스트는 스택이라는 자료구조로 관리(후입선출)


<12/26>
1. 식별자 : 어떤 ‘값’을 구별해서 식별할 수 있는 이름  (변수, 함수, 클래스 등의 이름)
	          => 값이 아니라 메모리 주소를 기억하고 있음

2. 값 : 표현식이 평가되어 생성된 ‘결과’


3. 표현식 : 값으로 평가될 수 있는 문
   => js의 모든 문은 표현식인 문과 표현식이 아닌 문으로 나뉜다.(해당 문을 변수에 할당할 수 있는가로 판단 가능)

   ex) 
      함수 선언문 =>  표현식이 아닌 문
      함수 리터럴, 함수 표현식 => 표현식인 문 

4. 토큰 : 문법적으로 더이상 나눌 수 없는 코드의 기본 요소  
    
5.  암묵적 형변환 시 falsy한 값들
	1) ‘’ : 빈문자열
        2) 0,-0  
        3) undefined
	4) null    : null의 typeof는 object이다
        5) NaN
        6) false
		

6.  js에서  var 변수는 선언 시 undefined로 초기화 
    선언과 동시에 값을 할당한다고 그 값으로 초기화 되는 것이 아니다
    
   let변수는 선언과 초기화가 나누어져 있음
    => 초기화 하기 전까지 참조불가 => TDZ(temporal dead zone)
     //따라서 호이스팅이 안되는 것처럼 보이지만 사실 되긴 함
      하여튼 초기화 전에 참조 불가
	
     +++ let, const로 선언한 전역 변수는 전역객체의 프로퍼티가 아님 (window.변수이름으로 접근x)
         var 혹은 암묵전 전역으로 선언한 변수, 전역으로 선언한 선언적 함수는 전역객체의 프로퍼티o 


7. 원시 데이터 타입으로 값이 할당된 변수에 값을 변경할 경우, 기존 메모리 공간이 아닌
      새로운 메모리 공간에 변경한 값을 생성해 보관


8. 객체 리터럴의 중괄호는 코드블럭이 아니다 => ; 붙이기 추천 


*9. 코드가 어디서 실행되고 주변에 어떤 코드가 있는가? : 렉시컬 스코프
    => 실행컨텍스트와의 차이는?? (23장 읽은 후  다시 생각해보기)

10. 스코프체인 : 스코프의 계층적 연결(변수를 참조할 때 상위 스코프 방향으로 이동하며 찾는다)
	     // 상속에서 자식은 부모의 자원을 사용할 수 있지만 부모가 자식의 자원을 사용할 수 없듯이
             // 상위 스코프에서 하위 스코프에서만 유효한 변수를 참조하는 경우는 없다 


11. 호이스팅은 런타임이 시작되기 이전에 식별자의 선언 및 초기화가 미리 실행되기 때문에 발생한다
      => 그래서 끌어 올려진 것처럼 보이는 것
        //**호이스팅 또한 스코프 단위로 동작한다
        스코프의 선두로 끌어 올려지는 것처럼 동작한다고 생각하면 될듯

12. 정적스코프와 동적스코프

    - 렉시컬 스코프 : 정적 스코프(함수를 어디서 선언했느냐에 따라 상위 스코프를 결정)
	                =>js는 렉시컬 스코프를 따른다.

    - 동적 스코프 : 함수를 어디서 호출했느냐에 따라 상위 스코프를 결정



13. 전역 객체 : 코드가 실행되기 이전 어떤 객체보다 제일 먼저 생성되는 객체    
             =>   브라우저 환경 : window       
                  node.js환경 : global

                    

14. 프로퍼티 어트리뷰트 :

 js는 프로퍼티를 생성할 때 프로퍼티의(객체의 키) '상태'를 나타내는 프로퍼티 어트리뷰트를 자동 정의함

  내부슬롯 => [[Value]], [[Writable]], [[Enumerable]](열거할 수 있는가?) , [[configurable]] 등으로 나타남 
        =>Object.getOwnPropertyDescriptor(객체의 참조 , 프로퍼티키의 문자열) 형식으로 조회 가능
          Object.defineProperty(객체의 참조, 프로퍼티의 문자열, 프로퍼티 디스크립터객체)를 통해 재정의 가능
          (여러 개면 .defineProperties 사용)


    - 크게 데이터 프로퍼티와 접근자 프로퍼티로 나뉨
	데이터 프로퍼티 : 자체적으로 값을 가지는 프로퍼티
	접근자 프로퍼티 : 자체적으로 값x, 다른 데이터프로퍼티의 값을 읽거나 저장

    - 데이터프로퍼티의 configurable이 false일 경우 객체.프로퍼티명의 형태로는 수정이 불가능하고   
      대신 접근자 프로퍼티로 설정한 setter에 의해서는 수정 가능
      => 자바의 클래스와 Private 접근제어자와  비슷한 느낌인걸까??

    - 수정이 안되게 얼리는 방법도 많음 
       1) Object.preventExtenstions(객체의 참조) => 프로퍼티 추가 방지
       2) Object.seal(객체의 참조) => 프로퍼티의 삭제 방지
       3) Object.freeze(객체의 참조) => 프로퍼티의 수정까지 방지 => 하지만 중첩된 객체까지 영향x
       //따라서 불변객체를 위해선 재귀적으로 Object.freeze를 호출해야 함      
       //(.key 메서드를 통해 프로퍼티를 배열로 만들고 .forEach를 통해 .freeze를 걸어버리는듯)

  
15. 생성자 함수 : new 함수이름(); 형태

 - new가 없으면 생성자의 역할을 하지 x   
  => new 가 있으면 내부메서드[[Construct]] 호출        
      ‘’    없으면 내부메서드[[Call]] 호출

 - 함수에서 return으로 반환하지 않더라도 
   new 키워드와 함께 사용하면 암묵적으로 인스턴스를 생성 후 this에 바인딩 
    => 런타임 이전에 빈 객체로 생성해서 선언된다.
      '생성자 함수가 실행될 때 인스턴스 초기화 및 할당'


16. 함수는 일급객체 

  - 무명의 리터럴로 생성 가능한가? => 런타임에 생성이 가능한가?
  - 변수나 자료구조에 저장이 가능한가? 
  - 함수의 매개변수로 전달 가능한가? 
  - 함수의 반환값으로 사용 가능한가? 
  
  함수는 모든 조건을 부합:     
  따라서 함수도 객체 프로퍼티를 갖는다=> length, name, arguments, caller, prototype 등 

       
  함수호출 시 매개변수의 개수가 자유로운 특성 때문에 
  'argument 프로퍼티'와 'Rest파라미터'를 사용해 전달받은 인수의 개수에 따라 다르게 동작하게 하는 방법이 자주 쓰임 
       
  *Rest 파라미터란  : (… 매개변수)의 형태로 
   매개변수 중 제일 마지막에 오며, 한번만 사용가능  
   앞에 선언된 매개변수들을 제외한 나머지 매개변수를 배열에 담아 할당한다 => 배열의 메서드 사용 가능   


<12/27>

17. 모든 객체는 [[Prototype]]이라는 내부슬롯을 가짐 => 객체의 생성방식에 따라 결정
     1)객체 리터럴에 의한 생성 => Object.prototype
     2)생성자 함수에 의한 생성 => 생성자함수의 prototype에 바인딩 되어 있는 객체

18. [[Prototye]] 내부슬롯에는 직접 접근 불가 
	=> 무분별하게 프로토타입 교체해 순환 참조와 같은 현상을 방지하기 위해
           (프로토타입체인의 단방향을 지키기 위해)

     (과거)
     .__proto__를 통해서 접근[[Get]],
     .__proto__ = 프로토타입으로 지정할 객체이름 (할당을 하면) [[Set]]
     

     (현재) //모든 객체가 _proto__를 사용할 수 있는 것이 아님 
           //(Object.protoype을 상속받지 않는 경우가 간혹가다 있을 수도)

      ==> 따라서 최근에는 .getPrototypeOf(프로토타입을 알아볼 객체이름)
	              .setPrototypeOf(프로토타입을 지정할 객체이름, 프로토타입으로 지정할 객체 이름)


19.생성자 함수객체는'prototype'이라는 프로퍼티 소유(내부슬롯 [[Prototype]]과 헷갈리지 않기)
        일반객체는 'prototype'프로퍼티 소유x


	* [[Prototype]] 개별객체의 속성 // .__proto__ 혹은 Object.getPrototypeOf()으로 접근
          .prototype   생성자함수의 속성   

         =>  Object.getPrototypeOf(new Foobar()) === Foobar.prototype



**(다시보기)20. 리터럴로 생성한 객체나 함수는 Object 생성자 함수나 Function 생성자 함수가 아니다.(구체적인 생성 방식이 다른듯)
							                       //생성과정과 스코프 클로저 등의 차이가 있음
    ==> 그런데 .constructor 를 통해 확인하면  Object생성자함수, Function생성자 함수라고 뜸
									       //기존 객체나 함수로서의 동일한 특성을 가짐
      ==> 내부동작에 의해 가상적인 생성자 함수를 갖는다(OrdinayObjectCreate라는 거에 의해 생성된다 함)

  	  //프로토타입과 생성자 함수는 반드시 쌍으로 존재해야 함

21. 따라서 모든 프로토타입은 생성자함수가 생성되는 시점에 동시에 생성된다
    - 빌트인 함수들의 생성자 ex) (Object, String, Number, Promise, Function 등 //Math는 해당x) 
      역시 생성될 때 그들의 프로토타입이 생성된다.
       => 빌트인 생성자 함수는 전역객체가 생성될 때 생성
       ==> 빌트인 생성자 함수의 프로토타입도 그래서 전역객체가 생성될 때 생성되어 빌트인 생성자 함수의 prototype프로퍼티에 바인딩된다

********
22. 위에서 아무리 어려운 소리를 해도 결국 중요한건
    모든 객체는 OrdinayObjectCreate라는 추상 연산에 의해 프로토타입이 결정되고 생성되며(최상위 Object.prototype은 null임)
    프로토타입과 프로토타입 체인이 존재함에 따라 상속을 구현할 수 있었고 코드의 재사용성을 높일 수 있었다

    함수의 경우 'prototype'이라는 프로퍼티에 의해
    객체의 경우 [[Prototype]]이라는 내부슬롯에  해당 프로토타입이 바인딩 되어있다.


24.js의 경우  프로토타입 메서드를 인스턴스에서 재정의(overriding)할 때 이를 프로퍼티 섀도잉이라고 함

25. 생성자 함수를 통해 객체를 만들고 난 뒤,
    객체 리터럴을 통해 생성자 함수의 프로토타입을 변경했을 경우(생성자함수의 프로토타입을 객체리터럴로 만든 객체로 변경했을 경우)
    객체 리터럴은 constructor라는 프로퍼티가 없으므로(따로 지정해주지 않았을 때)
    인스턴스의 생성자를 검색하면 Object.prototype이 나온다(체이닝을 타고 올라가서)

26. (25번 연장)당연한 이야기지만 생성자 함수에서 .prototype을 통해 프로토타입을 교체하는 건 말 그대로 교체이고
    인스턴스에서.setPrototypeOf()를 통해 프로토타입을 교체하는 건 기존 생성자 함수와의 관계를 끊는 일이다.
    근데 또 constructor:기존 생성자함수 이름, 처럼 프로퍼티에 직접 접근해서 다시 연결해줄 수도 있긴한데
    => 직접 교체하는 게 좋은 습관은 아니라고 함 (직접 상속이 더 편리하고 안전)
					Object.create(프로토타입으로 지정할 객체, ...)


<12/28>

27. 객체 식별자 instanceOf 생성자함수 
     좌항의 객체가 우항의 인스턴스인지(의해서 만들어졌는지) 검사
     *우측 생성자 함수의 prototype에 바인딩된 객체가 좌변의 프로토타입 체인 상에 존재하는가?
       (constructor를 기준으로 검색이 아니다)

28.정적 프로퍼티/메서드 (static)은 상속x 
   생성자 함수에서 선언된 정적 프로퍼티와 메서드는 생성된 인스턴스에서는 참조 및 호출 불가


29. key in object : object 안에 key이름의 프로퍼티가 존재하는가?
		  *(object의 프로토타입 체인상에 key이름의 프로퍼티가 존재하는가?)

  - Reflect.has(object, key) 도 동일한 역할

30. 객체에서의 for ... in 문
    => 단순 순회가 아니라 상속받은 프로퍼티도 열거한다고함
	**단, 정확히 말하면 프로퍼티 어트리뷰트에 [[Enumerable]]이 false인게 안 나오는듯
 	++ 심볼인 프로퍼티노 열거x

    따라서 본인이 가진 프로퍼티를 열거하려면 
     1) 조건으로 hasOwnProperty()를 사용하거나 
     2) Object.Keys(object)를 사용하는 것이 편하다 


<12/29>

31. 래퍼객체 : 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 '임시객체'
               => 원시타입의 데이터에도 연관 객체의 메서드를 사용기 위해

             const str= 'hi';
             clg(str.length); //str을 래퍼객체 String의 인스턴스로 변환 후 메서드 사용(이후 래퍼객체는 가비지 콜렉션 대상)
             clg(typeof str); //String이 나옴( 다시 원시 값으로 되돌림)
                              //str을 new String()을 통해 생성했으면 object가 나왔을 터


<12/31>

32. 암묵적 전역 : 선언하지 않은 식별자에 값을 할당하면 전역객체의 프로퍼티가 된다
               ex) y=20   //window.y = 20;
        	전역변수처럼 동작하지만 사실 프로퍼티이니 호이스팅 발생x 
                +delete 식별자로 삭제 가능



33.실행 컨텍스트 : 코드를 실행하는 데에 필요한 환경 제공 및 결과를 관리하는 영역
                (식별자를 등록하고 관리하는 스코프와 // 코드 실행 순서 관리를 구현한 내부 메커니즘)
                 실행컨텍스트의 렉시컬 환경             실행컨텍스트 스택


               크게 4가지 타입의 소스코드를 평가 후 실행 컨텍스트를 생성한다.
               1) 전역 코드 
               2) 함수 코드 
               3) eval 코드  
               4) 모듈 코드 


34. JS는 소스 코드의 평가와 소스 코드의 실행 과정으로 나누어서 처리함
    1) 소스코드를 평가하는 과정에서 선언된 식별자들(선언문)을 실행 컨텍스트가 관리하는 스코프에 등록 후 undefined로 초기화
    2) 소스코드가 실행되면서 이전에 실행된 선언문들을 제외하고 실행 (ex) 할당문 실행)
    3) 할당하려는 식별자가 선언 되어있는지 실행컨텍스트의 스코프에서 확인
    4) 선언되어 있다면 값을 할당 후 결과를 다시 실행컨텍스트의 스코프에 등록


35. 위의 과정이 반복적으로 굴러간다.
    <1> 전역코드 평가
    <2> 전역코드 실행
    <3> 함수코드 평가(함수 호출 시 전역 코드 실행 일시 정지//코드의 제어권이 호출된 함수 내부로 이동)
    <4> 함수코드 실행
    ...

   과 같은 순서로 실행되기 떄문에 스코프, 식별자,(+상태변화) 코드 실행 순서 등의 관리가 필요
   => 스코프 체인, 프로토타입 체인 등을 이용해 식별자를 검색 및 관리 
      +함수 호출 종료시 호출 이전 실행한 코드와 이후 실행할 코드 구분 등이 필요한데
      ==> 이를 실행 컨텍스트의 렉시컬환경과 스택으로 구현하고 있다는 것이 핵심


36. 생성된 실행 컨택스트는 스택이라는 자료구조로 관리(후입선출)


<1/2>

37. 클래스와 생성자 함수의 차이
     1) 클래스는 무조건 new와 함께. 아니면 에러 뜸 (생성자 함수는 new가 없을 시 일반함수로 호출)
     2) extends, super키워드 사용 가능
     3) class는 tdz 존재.(할당하기 전까지 참조불가)
     4) class 내부는 암묵적 strict mode
     5) class 내부의 constructor, 메서드(클래스 내부의 메서드는 프로토타입 메서드가 된다), 정적 메서드
        => 모두 [[Enumerable]] false 열거불가


38. 정적메서드, 프로토타입메서드 차이
    1) 둘이 속해있는 프로토타입체인이 다름
    2) 정적메서드는 클래스로 호출(상속이 안되니까), 프로토타입메서드는 인스턴스로 호출
    3) (2)의 연장) 인스턴스의 프로퍼티(필드)를 참조한다면 프로토타입 메서드로 작성해야 함

39. super 키워드
     1) super() : (super호출) 수퍼클래스의 constructor 호출
     2) super : (super참조) 수퍼클래스의 메서드 호출



39-1)   - 서브 클래스에서 constructor을 생략하지 않았을 경우 반드시 super 호출해야 함
          (constructor 생략했으면 상관x)
	- super() 호출 이전에 서브클래스에서 this로 수퍼클래스의 프로퍼티 접근 불가
        - constructor 안에서만 super() 호출 가능

39-2)	- super.메서드이름() : 수퍼클래스의 메서드를 가리킴
	- [[HomeObject]]내부슬롯을 가진 함수만이 super로 참조 가능
  	   => 메서드 축약 표현으로 정의한 함수만 [[HomeObject]] 가짐
        - 서브클래스의 정적 메서드 내에서 사용된 super는 수퍼(부모)클래스의 정적메서드를 가리킴


40. 클래스를 평가할 때 [[ConstructorKind]] 내부 슬롯을 통해 수퍼클래스와 서브클래스의 동작을 구분
    - [[ConstructorKind]] base : 다른 클래스를 상속받지 않는 클래스 => new 연산자와 호출 시  빈객체 생성 후 this에 바인딩
    - [[ConstructorKind]] derived : 파생된, 상속받은 클래스 => 인스턴스의 생성을 수퍼클래스에 위임 => super()를 반드시 호출해야하는 이유

      ** 서브 클래스에서 constructor 자체를 아예 생략해버리는 경우가 있는데 사실은 다음이 생략된 것과 같다
        (생략되지만 사실 다음과 같이 호출되고 있음)
      /*
	constructor(...arg){
	     super(...arg);
	 }
      */

41.  #을 통해 접근저에자 private를 비슷하게 흉내낼 수 있다

     class Person{
 	#name= '';		//이 경우 constructor 밖에 꼭 선언해줘야함
        constructor(name){
		this.#name = name;
 	}
     }

<1/3>

42. es6부터 객체 내부에 '메서드 축약 표현'으로 작성한 함수만 메서드라고 칭함
     => 이렇게 선언된 메서드는 non-constructor임
     ==> prototpye 프로퍼티도 x
     + [[HomeObject]]를 가짐 //수퍼클래스의 메서드를 참조하는 super키워드 사용가능


43. 화살표함수 특징
    1) 함수표현식으로만 정의 가능
    2) 매개변수 1개일 경우 ()생략 가능
    3) **함수의 몸체 내부가 표현식인 문이라면 {} 생략가능+ 암묵적 반환
       (하나의 문이라서 생략가능 한 것이 아니라 표현식인 문이라서 가능한 것!)==값으로 평가가 가능한 문인가?
    4) 객체리터럴을 반환하는 경우 ()를 감싸줘야 함.(아니면 함수블록 {}로 잘못 해석)


44. 일반함수와의 차이
    1) non-constructor임 (prototype속성도 없겠지?)
    2) 중복된 매개변수 이름 선언불가(일반함수에선(엄격모드 아닐 때) 이게 됐다고?? ㄷㄷ)
    3) 화살표함수 자체의 this, argument, super, new.target 바인딩을 안 가짐 
      => 상위 스코프 체인의 '화살표 함수가 아닌 함수'의 this를 참조(lexical this)
      ==>(충격)this가 바인딩을 가지지 않기 떄문에 .call .apply .bind로도 this 교체 불가
 

45. 배열.legnth에 값을 할당할 수가 있었네...
    다만 진짜 배열의 길이가 변경되는 것은 아니고 legnth 프로퍼티의 값이 바뀜...

46.js에서 배열은 사실 객체이기 때문에 delete를 통해 키(인덱스)에 해당하는 값 삭제가 가능함
   => 하지만 그러면 희소배열(연속적이지 않은 배열, 중간에 빈 요소가 있는 배열)이 되기 때문에 권장되는 방법이 아님
   ==> 따라서 splice()를 많이 씀

47. forEach, map, reduce, filter 등 메서드를 순회하는 메서드들은 희소배열의 경우 존재하지 않는 요소는 제외하고 진행


48. 유사배열객체  !== 이터러블객체 
    1)유사 배열 객체 : 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 가지는 객체 
                    Symbol.iterator메서드가 없어 for of 순회 불가// for in은 가능

    2) 이터러블 객체 : Symbol.iterator메서드를 구현하여 for of문으로 순회 가능 하고
                   스프레드 문법, 구조분해할당 등의 대상이 될 수 있는 객체  
                   (34장에서 자세히)


<1/5>

49. Number.EPSILON 
    : 1과 1보다 큰 숫자 중 가장 작은 숫자와의 차이
     =>부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용. 
        부동소수점을 2진법으로 변환하면 무한소수가 되어 오차가 발생함

50. 그 외 Number의 프로퍼티들
   - Number.MAX_VALUE  : js에서 표현할 수 있는 가장 큰 양수 값(보다 크면 Infinity)
   -       .MIN_VALUE   :                 가장 작은 양수 값(보다 작으면 0)
   -       .MAX_SAFE_INTEGER : 안전하게 표현할 수 있는 가장 큰 정수값


51. Number.isInfinite() : 인수로 전달된 값이 유한한가? //NaN의 경우 false
			++전달받은 인수를 암묵적 타입변환하지 않음 => 숫자가 오지 않으면 NaN이니까 무조건 false

    (전역함수) isInfinite() : 인수로 전달된 것울 암묵적으로 타입변환 함


  ** 이외의도  Numer래퍼객체의 메서드들은 인수로 전달되는 값들을 암묵적으로 타입변환하지 않는다
      빌트인 전역함수들과 이름이 겹칠 수도 있는데 헷갈리지 말 것

  *** Number래퍼객체의 메서드들을 숫자리터럴 뒤에 쓰는 경우 
      ex) 77.toExponetial => 77 다음에 오는 '.'이 부동 소수점인지 접근연산자인지 구분이 안된다.
         => (77).toExponential //"7.7e+1"  처럼 그룹연산자를 사용할 것을 권장


52. 심벌 값은 Symbol()을 호출하여 생성. (new와 함께 쓰지 않음)
     => 다른 값과 중복x
     ==> 문자열을 인수로 전달 받을 수 있는데 이는 설명? 디버깅의 역할만 할뿐 값 자체에는 영향x

    ex) const symbol1 = Symbol('test_key1');
	const symbol2 = Symbol('test_key1');

      clg(symbol1 === symbol2); //false

53. 심벌 값은 boolean형으로는 암묵적 타입변환이 이루어지지만
    '숫자', '문자열' 타입으로는 암묵적 형변환x


54.  Symbol함수를 통해 생성한 심벌 값은 호출될 때마다 유일무이한 값을 생성
      => but, 접근할 수 있는(검색할 수 있는) 키를 지정 못함
      ==> Symbol()로만 생성한 심벌 값은 전역 심벌 레지스트리에 등록되지 않는다

55. 따라서 Symbol.for()메서드를 사용
    : 전역 심벌 레지스트리에 '인자로 받은 값'이 키로 존재하지 않으면 새롭게 생성해서 등록
       + 존재한다면 기존에 있던 심벌값 반환

56. 심벌 값을 프로퍼티 키로 사용하면 
     : for...in문, Object.keys, Object.getOwnPropertyNames()에 검색x
   ==> 외부에 노출x. 은닉
   ===> Object.getOwnPropertySymbols()로는 검색 가능


57. 심벌은 중복되지 않는 값을 생성함으로
    기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해 사용한다고 한다.
    (하위 호환성을 위해)

***
58. 이터레이션 프로토콜 
    1) 이터러블 프로토콜
    2) 이터레이터 프로토콜


58-1) 이터러블
     : 이터러블 프로토콜을 준수하는 객체 
      =>  자바스크립트에서 제공하는 빌트인 심벌 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 구현했거나
          프로토타입 체인을 통해 상속받은 객체


58-2) 이터레이터 
    : 이터레이터 프로토콜을 준수하는 객체(이게 뭔 말 장난...)
      => Symbol.iterator 메서드를 호출하면 이터레이터를 반환하고
      ==> 이터레이터는 next메서드를 가진다
      ===> next메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 가지는
           이터레이터 리절트 객체가 반환된다.
	  
      ex)  const arr =  [1,2,3]; //이터러블 객체
             //이터러블객체 arr에 Symbol.iterator라는 프로퍼티명으로 접근 후 메서드 실행

	    clg(arr[Symbol.iterator]().next());   //{value:1, done:false}
	    clg(arr[Symbol.iterator]().next());   //{value:2, done:false}
	    clg(arr[Symbol.iterator]().next());   //{value:3, done:false}
	    clg(arr[Symbol.iterator]().next());   //{value:undefined, done:true}

      ※ 즉 이터러블 객체를 순회하기 위한 포인터 역할을 한다.

<1/6>

59. 스프레드 연산자 ... 의 결과는 값x
    =>변수에 할당 불가

    (스프레드문법) : 이터러블 객체에만 사용 가능 (유사배열 객체는 불가)   <--->    (Rest 파라미터) : 인수들의 목록을 배열 형태로 '묶는다'
	          이터러블 객체를 '펼쳐서' 개별적인 값의 목록으로

      1) 함수 호출문의 인수 목록 
      2) 배열 리터럴의 요소 목록
      3) 객체 리터럴의 프로퍼티 목록


60. 구조분해할당(디스트럭처링) => 구조화된 배열 혹은 이터러블 객체를 파괴해 1개 이상의 변수에 개별적으로 할당 (이터러블 객체에만 사용 가능)
                            //필요한 요소만 추출하여 값을 할당해야 할 때 주로 사용

                            할당 기준은 순서(인덱스)
     	                    변수의 개수와 이터러블의 요소 개수가 일치할 필요는 없음
                            ex)  const [a, b] = [1];   // a=1, b=undefined
                                 const[c, d] = [1,2,3]   //c=1, d=2
                                 const[ e, ,f] = [1,2,3]   //e =1, f=3


61. Set : 배열과 비슷해보이지만 수학적 집합에 가까움
          => 중복x, 인덱스 접근x, 순서x 

            .add() : 요소추가
	    .size() : 길이
            .has() : 요소 보유 여부
            .delete() : 요소 삭제(인수로 요소값을 받음)
	    .clear() : 모든 요소 삭제
	   

62. Map : 키와 값이 쌍으로 이루어졌다는 점에서 객체와 비슷해보이지만 다른 점이 있음
           1) 키로 모든 값이 올 수 있다 (객체는 문자열 혹은 심벌 값밖에 못 옴)
           2) 이터러블이다(일반객체는 Symbol.iterator를 프로퍼티이름으로 하는 메서드를 구현하기 이전엔 이터러블이 아님)

        *반드시 키와 값 쌍으로 이루어진 요소가 인수로 전달되어 생성되어야 함
       ex)   const map1 = new Map([['key1','value1'],['key2','value2']]);
             const map2 = new Map([['key3','value3']]);


            .set('key1', 'value1') : 요소 추가
	    .size(): 요소 개수 확인
	    .get('key1') : 요소 취득  //키로 접근
            .has()
            .delete()
            .clear()
            .keys() : 호출한 Map 객체의 키를 값으로 가지는 이터러블 객체 반환
            .values() : 호출한 Map객체의 값을 값으로 가지는 이터러블 객체 반환
            .entries() : 호출한 Map 객체의 키와 값을 가지는 (  [ , ]쌍으로  ) 이터러블 객체 반환


<1/8>

63. 클라이언트단에서 http 요청
     => html, css, js, img 등 리소스를 받음
     ==> html 파싱 : DOM 트리 생성 (생성 중 <link> 혹은 <style> , <script> 태그 만나서 외부 css js 호출하면 일시정지)
     ===> css 파싱 : CSSOM트리 생성 (만들고 다시 나가서 html 이어서 해석 및 DOM 생서 재개)

     ====> DOM + CSSOM 합쳐서 랜더 트리 생성(화면에 렌더링 되지 않는 노드는 표시x)

     ** 레이아웃이 추후에 변경되면 ex) 1) js DOM API 사용(노드 동적 추가 및 삭제)
				     2) 뷰포트에 따른 가변형
				     3) 레이아웃 변경 ex) margin, padding, display, position 등

	=>리렌더링 발생 :  DOM, CSSOM 변경(리플로우) + 다시 렌더 트리로 결합(리페인팅) 


     +> js 파싱 : css파싱 과정처럼  AST(추상구문트리 생성)  => 인터프리터가 실행할 수 있는 바이트코드 변환 및 실행
	


64. DOM트리를 구성하는 노드들 역시 js의 객체이기 때문에 (브라우저에서 제공하는 호스트 객체)
    =>프로토타입에 의한 상속구조를 가짐 + DOM API를 통해 조작이 가능하다


65. 복수의 요소를 취득하는 .getElementByClassName(), .getElementsByTagName()은 
    => '콜렉션객체' (유사배열+이터러블)을 반환함
    ==> 이 콜렉션 객체는 '실시간'반영 => 반복문을 돌던 도중 변경이 일어나면 바로 반영되니 주의

    **그래서 콜렉션 객체를 배열로 한번 변환해서 사용하는 것이 간단함  => [...콜렉션객체] 혹은 Array.from()


66. 마찬가지로 복수의 요소를 취득하는  .querySelectorAll()은 
    => '노드리스트'를 반환
    ===> 기본적으로 'non-live'라서 콜렉션객체처럼 실시간 반영x


67. 여러가지 DOM 조작 API

- 요소 내 텍스트노드 조작
   1) .innerHtml() :  html마크업 포함해서 반환 근데 파싱o 
   2) .textContent() : html마크업 안 가져옴. 파싱x  선택된 요소의 하위 텍스트까지 전부 다 긁어옴 숨겨진 것까지 (텍스트만, 마크업x)
   3) .nodeValue() :  요소노드.nodeValue()는 null, 텍스트요소.nodeValue()에서 원하는 텍스트가 나옴
                     요소.firstChild(텍스트노드).nodeValue()처럼 사용

   4) .innerText() : textContent()와 비슷. 텍스트만 가져오는데 css에 순종적이라 숨겨진 건 안 가져옴
                     +렌더링되는 텍스트만 가져옴
 


- .insertAdajacentHtml()
  => 첫번째인수로 'beforebegin', 'afterbegin', 'beforeend', 'afterend'등을 전달 받아 해당 위치에 삽입 (html마크업 파싱o)

- 이미 존재하는 요소를 다시 append해주면 이동된다??(맞음?)
- .insertBefore(newNode, childNode) : append, prepend 말고 2번쨰 인수로 지정한 노드 앞에 요소 추가

-.cloneNode() 요소 복사 
  (인수로 true를 전달받으면 깊은 복사(자손까지 다 복사)  || 기본값 false 얕은 복사 (자손노드 복사x)

- .replaceNode() 요소 교체
- .removeChild() 요소 삭제


68. html 어트리뷰트. => html 요소의 초기 상태
    DOM 어트리뷰트 => 사용자에 반응한 최신 상태 값


69. data어트리뷰트 
     data-이름 : data-index, data-user-id처럼 사용자 정의 어트리뷰트
                => .dataset.카멜케이스로 값을 취득하거나 변경 가능
		   ex) $li.datasetIndex ==='1' ? clg('1') : clg('2') ;
     

70. 이벤트 핸들러 : 이벤트가 발생했을 때 호출되는 함수


71. 1)이벤트 핸들러 프로퍼티 방식 : 요소.onclick= function(){...} 이런 형태
    2)이벤트 핸들러 어트리뷰트 방식 : html마크업 내부에 ( <button onclcik='핸들러이름()'> )
    3)이벤트 리스너 방식     :   요소.addEventListener('onclick',function(){}) 이런 형태
    

    - 프로퍼티 방식으로 같은 요소에 여러 핸들러를 달면 이전에 달았던 것은 실행x
    - 두 방식을 같이 사용할 수 있음 => 둘 다 실행
    - 이벤트리스너 방식은 여러 개 등록 가능=> 등록된 순서대로 실행

72. 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트핸들러는 .removeEventListener로 제거 불가
    => null을 할당해줘서 제거한다


<1/9>

73. 이벤트가 발생하면 이벤트에 관련된 정보를 담은 이벤트 객체가 동적으로 생성
      => ex) function clickColor(e){...} 
      ==> 첫번째 인수(e)로 전달된다  // ***이벤트 핸들러 어트리뷰트 방식으로는 반드시 매개변수 이름이 event여야한다.
       
74. 이벤트 핸들러가 바인딩된 DOM요소 => currentTarget 프로퍼티
    이벤트를 발생시킨 DOM요소 => traget 프로퍼티  

75. event 객체는 이벤트를 발생시킨 DOM요소를 중심으로 DOM트리를 통해 전파된다
     1) 캡처링 단계 : 상위요소 -> 하위요소
     2) 타깃 단계 :  이벤트가 target에 도달
     3) 버블링 단계 :  하위요소 -> 상위요소

      ex) currentTarget : ul에  click으로 이벤트가 묶여 있을 때
                 target : li 클릭 => 버블링 발생

         // 이벤트 리스너로 이벤트를 묶을 때 세번 째 매개변수의 값을 true로 설정하면 캡처링을 캐치할 수 있음
         ** focus/blur   load/unload/abort/error   mouseenter/mouseleave 이 세가지는 버블링 x

       + 캡처링 -> 타깃 -> 버블링 순으로 전파되는 것을 이용해 이벤트 핸들러의 호출 순서를 정할 수 있음   
       + 여러개의 하위 항목에 이벤트리스너를 달아줘야 하는 경우 => 이벤트 위임을 통해 상위 요소에 한번만 묶어줄 수도 있음
							    ==> 이 경우 e.stopPropagation() //이벤트전파 중단을 통해서 
                                    				하위 DOM요소의 개별적인 이벤트 처리도 가능함
        
76. 이벤트 핸들러 어트리뷰트 방식의 this : window(전역객체)
    이벤트 핸들러 프로퍼티 방식의 this : currentTarget( 핸들러를 바인딩한 DOM요소) //화살표함수가 아닐 때 
    이벤트 리스너의 this : currentTarget    //화살표함수가 아닐 때

77. 커스텀 이벤트 : 
   
    개발자가 의도적으로 이벤트 객체를 만들 수 있음 (이벤트 생성자 함수로 생성 가능)
    ex)  const keyBoardEvent = new KeyBoardEvent('keyup');
         const customEvent = new CustomEvent("이벤트타입이름");

    이렇게 생성된 커스텀 이벤트는 이벤트 리스너를 통해서만 핸들러 등록 가능(on+이벤트타입 이름이 요소노드에 존재x 때문에)
    =>dispatchEvent() 메서드를 통해 이벤트를 발생시킬 수 있다
    ==> 다만 동기적이다.(원래 이벤트리스너는 비동기적 처리)
 


<1/10>

78. 디바운스와 스로틀 : 스크롤,리사이즈처럼 짧은 시간 간격으로 연속해서 이벤트 발생 => 과도한 호출 => 성능문제
                       이를 방지하기 위한 프로그래밍 기법

   - 디바운스 : 연속해서 이벤트가 발생할 경우, 이벤트를 그룹화하여 마지막에 이벤트 핸들러가 한번만 호출되도록
               // 콜백함수와 delay를 인수로 받아 딜레이보다 이벤트가 더 빨리 발생할 경우 => 이전 타이머취소, 새로운 타이머 재설성
                                                                                    ==> 딜레이보다 짧은 간격으로 발생하면 콜백호출x 
											(핸들러가 연속되어서 호출된다면, 제일 마지막 것만 호출)


   - 스로틀 : 이벤트를 일정주기마다 발생 => 마지막함수가 호출된 후 일정시간이 지나야 호출 가능하게
	     (성능에 제한?제약?을 건다?라는 느낌)

  =====> 둘 다 직접 구현하기보단 Underscore나 Lodash의 외부라이브러리를 사용하는듯?


79. 태스크 큐 : 비동기함수의 콜백함수 혹은 이벤트 핸들러들이 일시적으로 보관되는 영역
		(비동기 처리 관련 함수 보관?)

80. 이벤트루프 : 콜스택(실행컨텍스트 스택)에 현재 실행 중인 컨텍스트가 있는지? 태스크 큐에 대기 중인 함수(콜백 혹은 핸들러)가 있는지 반복해서 확인
                => 만약 콜스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 
                ==> 이벤트루프는 순차적으로(선입선출) 태스크 큐에 대기 중인 함수를 콜스택으로 이동시킴(실행시킴)


81. 자바스크립트는 싱글스레드지만 브라우저는 멀티스레드이다  
     ==> 이벤트루프와 태스크 큐는 자바스크립트 엔진에 포함x (브라우저 환경에 포함)

<1/11>

82. JSON.stringify() => 직렬화

83. XMLHttpRequest객체 : form태그를 통한 http요청이 아닌 js를 사용해 요청을 보내고 싶을 때 사용 
    
84. 요청 처리 과정
     1) const xhr = new XMLHttpRequest();  			   //XMLHttpRequest객체 생성
     2) xhr.open('GET', 'url'); 	    			   //Http 요청 초기화
     3) xhr.setRequestHeader('content-type', 'application/json');  //Http 요청 헤더 설정, 반드시 open메서드 이후에 사용
								   //페이로드(데이터)의 MIME타입 지정을 주로 한다고 함
     4) xhr.send('페이로드'); 					   //Http 요청 전송

85. 요청 메서드 
    1) GET    : 리소스 취득   , 페이로드x
    2) POST   : 리소스 생성 (status는201)  , 페이로드o
    3) PUT    : 리소스 전체 교체  , 페이로드o
    4) PATCH  : 리소스 일부수정  , 페이로드o
    5) DELETE : 리소스 삭제 , 페이로드x

86. 페이로드 : 실질적인 사용이 있어서 전송되는 데이터 
              ex) POST 메서드의 body안에 있는 데이터  

86. 응답 처리 과정
    1) 요청을 처리한 후
    2) xhr.onreadystatechange = () => {   //.onload() 사용이 더 좋은듯
	if(xhr.readystate !== XMLHttpRequest.DONE) return; // 응답이 아직 안되었다면 그냥 끝내
	if(xhr.status === 200){ 
		clg(JSON.parse(xhr.response); //만약 상태코드200뜨면 응답결과 보여줘
	}else{
		clg('에러발생') // 만약 상태코드가 200이 아니면 에러발생이라고 보여줘	
	}
       }


87. REST API
         REST(Representational State Transfer) 
         : HTTP의 장점을 잘 활용할 수 있게 '클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처'

          ==> REST API : REST를 기반으로 서비스 API를 구현한 것

	  3요소) 자원(URI 사용), 행위(HTTP요청메서드 사용), 표현(페이로드 사용)
   	  HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,
	  HTTP Method(POST, GET, PUT, DELETE, PATCH 등)를 통해 자원에 대한 행위를 명시하고,
          payload를 통해 자원에 대한 행위의 구처적 내용을 명시하자


88. 일반적인 비동기처리는 처리결과를 외부로 반환하거나  상위 스코프의 변수에 할당할 수가 없음
    ==> 비동기함수를 호출해도 함수 내부의 비동기로 동작하는 코드가 완료되지 않은 채로 호출한 함수가 종료되니깐
    ===> 이를 처리하기 위해서는 1)비동기처리 결과에 대한 후속처리를 수행하는 또 다른 비동기 함수를 또 호출 해야 함
    ====> 콜백함수 호출의 중첩으로 복잡도가 높아짐(콜백 헬)
    =====> 이를 보완하고자 프로미스가 등장


89. 프로미스 객체 :  비동기 처리 상태와 처리결과를 관리하는 객체 
		비동기 처리를 수행할 콜백함수를 인수로 받음 (resolve, reject)

90. 프로미스의 상태정보
     pending           ->  settled :  resolve함수를 호출하면fullfiled
				      reject함수를 호출하면 rejected
(비동기 처리 수행x) 	      (비동기 처리 수행 완료한 상태)


91. 프로미스의 '후속처리' 메서드 => 무조건 다시 프로미스로 반환   
    1) .then(v, e)   : v(첫번째 인수 성공했을 때), e(두번째인수 실패했을 때) 
		       //그래서 주로 인수를 하나만(첫번째만) 받고 e는 .catch를 체이닝해서 쓰는듯
    2) .catch(e) : 인수 e하나만 받음
    3) .finally() : 콜백함수를 인수로 받음. 성공, 실패 상관없이 무조건 한번 호출



<1/11>

92.프로미스 객체의 정적 메서드

   1) Promise.resolve() :인수로 전달 받은 값을 래핑해 fulfilled 상태의 프로미스 반환
   2) Promise.reject() : 인수로 전달 받은 값을 래핑해 rejected 상태의 프로미스 반환
      // 둘 다 프로미스를 인수로 받으면 프로미스 그대로 뱉음

  3) Promise.all() : 여러 개의 프로미스를 병렬처리할 때 사용
                     인수로 프로미스를 요소로 가지는 이터러블을 받음
                     인수로 전달받은 프로미스들이 전부 fulfilled되면 종료 //하나라도 rejected되면 그 즉시 종료

  4) Promise.race() : .all과 비슷한데 제일 먼저 fulfilled된 프로미스만 새로운 프로미스로 반환
  5) Promise.allSetteld() : 마찬가지로 인수로 프로미스를 요소로 갖는 이터러블을 받고 
                            전달받은 프로미스가 전부 setteld가 되면 처리결과를 배열로 반환

93. 프로미스의 후속처리 메서드들은 비동기 처리지만 태스크큐가 아닌
    '마이크로 태스크큐'에 저장되며 우선순위가 일반 태스크큐에 있는 비동기함수들보다 높다


94. fatch() : 응답을 나타내는 Response객체를
              자체적으로 프로미스로 래핑 후 반환해 더 편리하게 요청처리를 할 수 있음.

    ex).  const promise = fetch('uri', {
		             method : 'POST',
			     headers : {'content-Type', 'application/json'},
			     body : JSON.stringify("페이로드 내용")
			   }

     +Response객체가 제공하는 여러 프로퍼티, 메서드 사용 가능
     ++ fecth함수가 반환하는 프로미스는 Response객체의 ok프로퍼티가 false인 것만 reject
         ==> 404, 500이 fulfilled로 넘어감
         ===> response.ok가 false인 것을 거르거나(조건문) axios사용


95.제너레이터 : 코드블럭의 실행을 일시중지 했다가 원하는 시점에 이어서 진행할 수 있는 특수한 함수

             - function* 함수이름(){...}과 같은 형태로 선언
             - 호출 시 제너레이터 객체 생성 후 반환
               제너레이터 객체는 이터러블이면서 이터레이터이다 (.next()통해서 리절트 객체 받음)
             - yeild라는 표현식을 반드시 가짐
             - new 키워드, 화살표함수로 사용불가
            

96.제너레이터의 메서드
    1) .next() : yeild 표현식을 만날 때까지 코드 실행. => 함수의 제어권을 호출자에게 양도
                 yeild의 값을 value, false를 done으로 가지는 리절트 객체 반환

    2) .return() : 인수로 전달 받은 값을 value, true를 done으로 가지는 리절트 객체 반환
    3) .throw() : 인수로 전달받은 에러를 발생. undefined를 value로, true를 done으로 가지는 리절트 객체 반환



(여기서브터 다시보기)
97. 에러는 호출자 방향으로 전파된다
    => 동기처리일 경우 중간에 그냥 멈춰버림 코드 실행을 끝마치지 않고

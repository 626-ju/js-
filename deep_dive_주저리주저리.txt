<12/26>
1. 식별자 : 어떤 ‘값’을 구별해서 식별할 수 있는 이름  (변수, 함수, 클래스 등의 이름)
	          => 값이 아니라 메모리 주소를 기억하고 있음

2. 값 : 표현식이 평가되어 생성된 ‘결과’


3. 표현식 : 값으로 평가될 수 있는 문
   => js의 모든 문은 표현식인 문과 표현식이 아닌 문으로 나뉜다.(해당 문을 변수에 할당할 수 있는가로 판단 가능)

   ex) 
      함수 선언문 =>  표현식이 아닌 문
      함수 리터럴, 함수 표현식 => 표현식인 문 

4. 토큰 : 문법적으로 더이상 나눌 수 없는 코드의 기본 요소  
    
5.  암묵적 형변환 시 falsy한 값들
	1) ‘’ : 빈문자열
        2) 0,-0  
        3) undefined
	4) null    : null의 typeof는 object이다
        5) NaN
        6) false
		

6.  js에서  var 변수는 선언 시 undefined로 초기화 
    선언과 동시에 값을 할당한다고 그 값으로 초기화 되는 것이 아니다
    
   let변수는 선언과 초기화가 나누어져 있음
    => 초기화 하기 전까지 참조불가 => TDZ(temporal dead zone)
     //따라서 호이스팅이 안되는 것처럼 보이지만 사실 되긴 함
      하여튼 초기화 전에 참조 불가
	
     +++ let, const로 선언한 전역 변수는 전역객체의 프로퍼티가 아님 (window.변수이름으로 접근x)
         var 혹은 암묵전 전역으로 선언한 변수, 전역으로 선언한 선언적 함수는 전역객체의 프로퍼티o 


7. 원시 데이터 타입으로 값이 할당된 변수에 값을 변경할 경우, 기존 메모리 공간이 아닌
      새로운 메모리 공간에 변경한 값을 생성해 보관


8. 객체 리터럴의 중괄호는 코드블럭이 아니다 => ; 붙이기 추천 


*9. 코드가 어디서 실행되고 주변에 어떤 코드가 있는가? : 렉시컬 스코프
    => 실행컨텍스트와의 차이는?? (23장 읽은 후  다시 생각해보기)

10. 스코프체인 : 스코프의 계층적 연결(변수를 참조할 때 상위 스코프 방향으로 이동하며 찾는다)
	     // 상속에서 자식은 부모의 자원을 사용할 수 있지만 부모가 자식의 자원을 사용할 수 없듯이
             // 상위 스코프에서 하위 스코프에서만 유효한 변수를 참조하는 경우는 없다 


11. 호이스팅은 런타임이 시작되기 이전에 식별자의 선언 및 초기화가 미리 실행되기 때문에 발생한다
      => 그래서 끌어 올려진 것처럼 보이는 것
        //**호이스팅 또한 스코프 단위로 동작한다
        스코프의 선두로 끌어 올려지는 것처럼 동작한다고 생각하면 될듯

12. 정적스코프와 동적스코프

    - 렉시컬 스코프 : 정적 스코프(함수를 어디서 선언했느냐에 따라 상위 스코프를 결정)
	                =>js는 렉시컬 스코프를 따른다.

    - 동적 스코프 : 함수를 어디서 호출했느냐에 따라 상위 스코프를 결정



13. 전역 객체 : 코드가 실행되기 이전 어떤 객체보다 제일 먼저 생성되는 객체    
             =>   브라우저 환경 : window       
                  node.js환경 : global

                    

14. 프로퍼티 어트리뷰트 :

 js는 프로퍼티를 생성할 때 프로퍼티의(객체의 키) '상태'를 나타내는 프로퍼티 어트리뷰트를 자동 정의함

  내부슬롯 => [[Value]], [[Writable]], [[Enumerable]](열거할 수 있는가?) , [[configurable]] 등으로 나타남 
        =>Object.getOwnPropertyDescriptor(객체의 참조 , 프로퍼티키의 문자열) 형식으로 조회 가능
          Object.defineProperty(객체의 참조, 프로퍼티의 문자열, 프로퍼티 디스크립터객체)를 통해 재정의 가능
          (여러 개면 .defineProperties 사용)


    - 크게 데이터 프로퍼티와 접근자 프로퍼티로 나뉨
	데이터 프로퍼티 : 자체적으로 값을 가지는 프로퍼티
	접근자 프로퍼티 : 자체적으로 값x, 다른 데이터프로퍼티의 값을 읽거나 저장

    - 데이터프로퍼티의 configurable이 false일 경우 객체.프로퍼티명의 형태로는 수정이 불가능하고   
      대신 접근자 프로퍼티로 설정한 setter에 의해서는 수정 가능
      => 자바의 클래스와 Private 접근제어자와  비슷한 느낌인걸까??

    - 수정이 안되게 얼리는 방법도 많음 
       1) Object.preventExtenstions(객체의 참조) => 프로퍼티 추가 방지
       2) Object.seal(객체의 참조) => 프로퍼티의 삭제 방지
       3) Object.freeze(객체의 참조) => 프로퍼티의 수정까지 방지 => 하지만 중첩된 객체까지 영향x
       //따라서 불변객체를 위해선 재귀적으로 Object.freeze를 호출해야 함      
       //(.key 메서드를 통해 프로퍼티를 배열로 만들고 .forEach를 통해 .freeze를 걸어버리는듯)

  
15. 생성자 함수 : new 함수이름(); 형태

 - new가 없으면 생성자의 역할을 하지 x   
  => new 가 있으면 내부메서드[[Construct]] 호출        
      ‘’    없으면 내부메서드[[Call]] 호출

 - 함수에서 return으로 반환하지 않더라도 
   new 키워드와 함께 사용하면 암묵적으로 인스턴스를 생성 후 this에 바인딩 
    => 런타임 이전에 빈 객체로 생성해서 선언된다.
      '생성자 함수가 실행될 때 인스턴스 초기화 및 할당'


16. 함수는 일급객체 

  - 무명의 리터럴로 생성 가능한가? => 런타임에 생성이 가능한가?
  - 변수나 자료구조에 저장이 가능한가? 
  - 함수의 매개변수로 전달 가능한가? 
  - 함수의 반환값으로 사용 가능한가? 
  
  함수는 모든 조건을 부합:     
  따라서 함수도 객체 프로퍼티를 갖는다=> length, name, arguments, caller, prototype 등 

       
  함수호출 시 매개변수의 개수가 자유로운 특성 때문에 
  'argument 프로퍼티'와 'Rest파라미터'를 사용해 전달받은 인수의 개수에 따라 다르게 동작하게 하는 방법이 자주 쓰임 
       
  *Rest 파라미터란  : (… 매개변수)의 형태로 
   매개변수 중 제일 마지막에 오며, 한번만 사용가능  
   앞에 선언된 매개변수들을 제외한 나머지 매개변수를 배열에 담아 할당한다 => 배열의 메서드 사용 가능   


<12/27>

17. 모든 객체는 [[Prototype]]이라는 내부슬롯을 가짐 => 객체의 생성방식에 따라 결정
     1)객체 리터럴에 의한 생성 => Object.prototype
     2)생성자 함수에 의한 생성 => 생성자함수의 prototype에 바인딩 되어 있는 객체

18. [[Prototye]] 내부슬롯에는 직접 접근 불가 
	=> 무분별하게 프로토타입 교체해 순환 참조와 같은 현상을 방지하기 위해
           (프로토타입체인의 단방향을 지키기 위해)

     (과거)
     .__proto__를 통해서 접근[[Get]],
     .__proto__ = 프로토타입으로 지정할 객체이름 (할당을 하면) [[Set]]
     

     (현재) //모든 객체가 _proto__를 사용할 수 있는 것이 아님 
           //(Object.protoype을 상속받지 않는 경우가 간혹가다 있을 수도)

      ==> 따라서 최근에는 .getPrototypeOf(프로토타입을 알아볼 객체이름)
	              .setPrototypeOf(프로토타입을 지정할 객체이름, 프로토타입으로 지정할 객체 이름)


19.생성자 함수객체는'prototype'이라는 프로퍼티 소유(내부슬롯 [[Prototype]]과 헷갈리지 않기)
        일반객체는 'prototype'프로퍼티 소유x


	* [[Prototype]] 개별객체의 속성 // .__proto__ 혹은 Object.getPrototypeOf()으로 접근
          .prototype   생성자함수의 속성   

         =>  Object.getPrototypeOf(new Foobar()) === Foobar.prototype



**(다시보기)20. 리터럴로 생성한 객체나 함수는 Object 생성자 함수나 Function 생성자 함수가 아니다.(구체적인 생성 방식이 다른듯)
							                       //생성과정과 스코프 클로저 등의 차이가 있음
    ==> 그런데 .constructor 를 통해 확인하면  Object생성자함수, Function생성자 함수라고 뜸
									       //기존 객체나 함수로서의 동일한 특성을 가짐
      ==> 내부동작에 의해 가상적인 생성자 함수를 갖는다(OrdinayObjectCreate라는 거에 의해 생성된다 함)

  	  //프로토타입과 생성자 함수는 반드시 쌍으로 존재해야 함

21. 따라서 모든 프로토타입은 생성자함수가 생성되는 시점에 동시에 생성된다
    - 빌트인 함수들의 생성자 ex) (Object, String, Number, Promise, Function 등 //Math는 해당x) 
      역시 생성될 때 그들의 프로토타입이 생성된다.
       => 빌트인 생성자 함수는 전역객체가 생성될 때 생성
       ==> 빌트인 생성자 함수의 프로토타입도 그래서 전역객체가 생성될 때 생성되어 빌트인 생성자 함수의 prototype프로퍼티에 바인딩된다

********
22. 위에서 아무리 어려운 소리를 해도 결국 중요한건
    모든 객체는 OrdinayObjectCreate라는 추상 연산에 의해 프로토타입이 결정되고 생성되며(최상위 Object.prototype은 null임)
    프로토타입과 프로토타입 체인이 존재함에 따라 상속을 구현할 수 있었고 코드의 재사용성을 높일 수 있었다

    함수의 경우 'prototype'이라는 프로퍼티에 의해
    객체의 경우 [[Prototype]]이라는 내부슬롯에  해당 프로토타입이 바인딩 되어있다.


24.js의 경우  프로토타입 메서드를 인스턴스에서 재정의(overriding)할 때 이를 프로퍼티 섀도잉이라고 함

25. 생성자 함수를 통해 객체를 만들고 난 뒤,
    객체 리터럴을 통해 생성자 함수의 프로토타입을 변경했을 경우(생성자함수의 프로토타입을 객체리터럴로 만든 객체로 변경했을 경우)
    객체 리터럴은 constructor라는 프로퍼티가 없으므로(따로 지정해주지 않았을 때)
    인스턴스의 생성자를 검색하면 Object.prototype이 나온다(체이닝을 타고 올라가서)

26. (25번 연장)당연한 이야기지만 생성자 함수에서 .prototype을 통해 프로토타입을 교체하는 건 말 그대로 교체이고
    인스턴스에서.setPrototypeOf()를 통해 프로토타입을 교체하는 건 기존 생성자 함수와의 관계를 끊는 일이다.
    근데 또 constructor:기존 생성자함수 이름, 처럼 프로퍼티에 직접 접근해서 다시 연결해줄 수도 있긴한데
    => 직접 교체하는 게 좋은 습관은 아니라고 함 (직접 상속이 더 편리하고 안전)
					Object.create(프로토타입으로 지정할 객체, ...)


<12/28>

27. 객체 식별자 instanceOf 생성자함수 
     좌항의 객체가 우항의 인스턴스인지(의해서 만들어졌는지) 검사
     *우측 생성자 함수의 prototype에 바인딩된 객체가 좌변의 프로토타입 체인 상에 존재하는가?
       (constructor를 기준으로 검색이 아니다)

28.정적 프로퍼티/메서드 (static)은 상속x 
   생성자 함수에서 선언된 정적 프로퍼티와 메서드는 생성된 인스턴스에서는 참조 및 호출 불가


29. key in object : object 안에 key이름의 프로퍼티가 존재하는가?
		  *(object의 프로토타입 체인상에 key이름의 프로퍼티가 존재하는가?)

  - Reflect.has(object, key) 도 동일한 역할

30. 객체에서의 for ... in 문
    => 단순 순회가 아니라 상속받은 프로퍼티도 열거한다고함
	**단, 정확히 말하면 프로퍼티 어트리뷰트에 [[Enumerable]]이 false인게 안 나오는듯
 	++ 심볼인 프로퍼티노 열거x

    따라서 본인이 가진 프로퍼티를 열거하려면 
     1) 조건으로 hasOwnProperty()를 사용하거나 
     2) Object.Keys(object)를 사용하는 것이 편하다 


<12/29>

31. 래퍼객체 : 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 '임시객체'
               => 원시타입의 데이터에도 연관 객체의 메서드를 사용기 위해

             const str= 'hi';
             clg(str.length); //str을 래퍼객체 String의 인스턴스로 변환 후 메서드 사용(이후 래퍼객체는 가비지 콜렉션 대상)
             clg(typeof str); //String이 나옴( 다시 원시 값으로 되돌림)
                              //str을 new String()을 통해 생성했으면 object가 나왔을 터


<12/31>

32. 암묵적 전역 : 선언하지 않은 식별자에 값을 할당하면 전역객체의 프로퍼티가 된다
               ex) y=20   //window.y = 20;
        	전역변수처럼 동작하지만 사실 프로퍼티이니 호이스팅 발생x 
                +delete 식별자로 삭제 가능



33.실행 컨텍스트 : 코드를 실행하는 데에 필요한 환경 제공 및 결과를 관리하는 영역
                (식별자를 등록하고 관리하는 스코프와 // 코드 실행 순서 관리를 구현한 내부 메커니즘)
                 실행컨텍스트의 렉시컬 환경             실행컨텍스트 스택


               크게 4가지 타입의 소스코드를 평가 후 실행 컨텍스트를 생성한다.
               1) 전역 코드 
               2) 함수 코드 
               3) eval 코드  
               4) 모듈 코드 


34. JS는 소스 코드의 평가와 소스 코드의 실행 과정으로 나누어서 처리함
    1) 소스코드를 평가하는 과정에서 선언된 식별자들(선언문)을 실행 컨텍스트가 관리하는 스코프에 등록 후 undefined로 초기화
    2) 소스코드가 실행되면서 이전에 실행된 선언문들을 제외하고 실행 (ex) 할당문 실행)
    3) 할당하려는 식별자가 선언 되어있는지 실행컨텍스트의 스코프에서 확인
    4) 선언되어 있다면 값을 할당 후 결과를 다시 실행컨텍스트의 스코프에 등록


35. 위의 과정이 반복적으로 굴러간다.
    <1> 전역코드 평가
    <2> 전역코드 실행
    <3> 함수코드 평가(함수 호출 시 전역 코드 실행 일시 정지//코드의 제어권이 호출된 함수 내부로 이동)
    <4> 함수코드 실행
    ...

   과 같은 순서로 실행되기 떄문에 스코프, 식별자,(+상태변화) 코드 실행 순서 등의 관리가 필요
   => 스코프 체인, 프로토타입 체인 등을 이용해 식별자를 검색 및 관리 
      +함수 호출 종료시 호출 이전 실행한 코드와 이후 실행할 코드 구분 등이 필요한데
      ==> 이를 실행 컨텍스트의 렉시컬환경과 스택으로 구현하고 있다는 것이 핵심


36. 생성된 실행 컨택스트는 스택이라는 자료구조로 관리(후입선출)


<1/2>

37. 클래스와 생성자 함수의 차이
     1) 클래스는 무조건 new와 함께. 아니면 에러 뜸 (생성자 함수는 new가 없을 시 일반함수로 호출)
     2) extends, super키워드 사용 가능
     3) class는 tdz 존재.(할당하기 전까지 참조불가)
     4) class 내부는 암묵적 strict mode
     5) class 내부의 constructor, 메서드(클래스 내부의 메서드는 프로토타입 메서드가 된다), 정적 메서드
        => 모두 [[Enumerable]] false 열거불가


38. 정적메서드, 프로토타입메서드 차이
    1) 둘이 속해있는 프로토타입체인이 다름
    2) 정적메서드는 클래스로 호출(상속이 안되니까), 프로토타입메서드는 인스턴스로 호출
    3) (2)의 연장) 인스턴스의 프로퍼티(필드)를 참조한다면 프로토타입 메서드로 작성해야 함

39. super 키워드
     1) super() : (super호출) 수퍼클래스의 constructor 호출
     2) super : (super참조) 수퍼클래스의 메서드 호출



39-1)   - 서브 클래스에서 constructor을 생략하지 않았을 경우 반드시 super 호출해야 함
          (constructor 생략했으면 상관x)
	- super() 호출 이전에 서브클래스에서 this로 수퍼클래스의 프로퍼티 접근 불가
        - constructor 안에서만 super() 호출 가능

39-2)	- super.메서드이름() : 수퍼클래스의 메서드를 가리킴
	- [[HomeObject]]내부슬롯을 가진 함수만이 super로 참조 가능
  	   => 메서드 축약 표현으로 정의한 함수만 [[HomeObject]] 가짐
        - 서브클래스의 정적 메서드 내에서 사용된 super는 수퍼(부모)클래스의 정적메서드를 가리킴


40. 클래스를 평가할 때 [[ConstructorKind]] 내부 슬롯을 통해 수퍼클래스와 서브클래스의 동작을 구분
    - [[ConstructorKind]] base : 다른 클래스를 상속받지 않는 클래스 => new 연산자와 호출 시  빈객체 생성 후 this에 바인딩
    - [[ConstructorKind]] derived : 파생된, 상속받은 클래스 => 인스턴스의 생성을 수퍼클래스에 위임 => super()를 반드시 호출해야하는 이유

      ** 서브 클래스에서 constructor 자체를 아예 생략해버리는 경우가 있는데 사실은 다음이 생략된 것과 같다
        (생략되지만 사실 다음과 같이 호출되고 있음)
      /*
	constructor(...arg){
	     super(...arg);
	 }
      */

41.  #을 통해 접근저에자 private를 비슷하게 흉내낼 수 있다

     class Person{
 	#name= '';		//이 경우 constructor 밖에 꼭 선언해줘야함
        constructor(name){
		this.#name = name;
 	}
     }

<1/3>

42. es6부터 객체 내부에 '메서드 축약 표현'으로 작성한 함수만 메서드라고 칭함
     => 이렇게 선언된 메서드는 non-constructor임
     ==> prototpye 프로퍼티도 x
     + [[HomeObject]]를 가짐 //수퍼클래스의 메서드를 참조하는 super키워드 사용가능


43. 화살표함수 특징
    1) 함수표현식으로만 정의 가능
    2) 매개변수 1개일 경우 ()생략 가능
    3) **함수의 몸체 내부가 표현식인 문이라면 {} 생략가능+ 암묵적 반환
       (하나의 문이라서 생략가능 한 것이 아니라 표현식인 문이라서 가능한 것!)==값으로 평가가 가능한 문인가?
    4) 객체리터럴을 반환하는 경우 ()를 감싸줘야 함.(아니면 함수블록 {}로 잘못 해석)


44. 일반함수와의 차이
    1) non-constructor임 (prototype속성도 없겠지?)
    2) 중복된 매개변수 이름 선언불가(일반함수에선(엄격모드 아닐 때) 이게 됐다고?? ㄷㄷ)
    3) 화살표함수 자체의 this, argument, super, new.target 바인딩을 안 가짐 
      => 상위 스코프 체인의 '화살표 함수가 아닌 함수'의 this를 참조(lexical this)
      ==>(충격)this가 바인딩을 가지지 않기 떄문에 .call .apply .bind로도 this 교체 불가
 

45. 배열.legnth에 값을 할당할 수가 있었네...
    다만 진짜 배열의 길이가 변경되는 것은 아니고 legnth 프로퍼티의 값이 바뀜...

46.js에서 배열은 사실 객체이기 때문에 delete를 통해 키(인덱스)에 해당하는 값 삭제가 가능함
   => 하지만 그러면 희소배열(연속적이지 않은 배열, 중간에 빈 요소가 있는 배열)이 되기 때문에 권장되는 방법이 아님
   ==> 따라서 splice()를 많이 씀

47. forEach, map, reduce, filter 등 메서드를 순회하는 메서드들은 희소배열의 경우 존재하지 않는 요소는 제외하고 진행


48. 유사배열객체  !== 이터러블객체 
    1)유사 배열 객체 : 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 가지는 객체 
                    Symbol.iterator메서드가 없어 for of 순회 불가// for in은 가능

    2) 이터러블 객체 : Symbol.iterator메서드를 구현하여 for of문으로 순회 가능 하고
                   스프레드 문법, 구조분해할당 등의 대상이 될 수 있는 객체  
                   (34장에서 자세히)


<1/5>

49. Number.EPSILON 
    : 1과 1보다 큰 숫자 중 가장 작은 숫자와의 차이
     =>부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용. 
        부동소수점을 2진법으로 변환하면 무한소수가 되어 오차가 발생함

50. 그 외 Number의 프로퍼티들
   - Number.MAX_VALUE  : js에서 표현할 수 있는 가장 큰 양수 값(보다 크면 Infinity)
   -       .MIN_VALUE   :                 가장 작은 양수 값(보다 작으면 0)
   -       .MAX_SAFE_INTEGER : 안전하게 표현할 수 있는 가장 큰 정수값


51. Number.isInfinite() : 인수로 전달된 값이 유한한가? //NaN의 경우 false
			++전달받은 인수를 암묵적 타입변환하지 않음 => 숫자가 오지 않으면 NaN이니까 무조건 false

    (전역함수) isInfinite() : 인수로 전달된 것울 암묵적으로 타입변환 함


  ** 이외의도  Numer래퍼객체의 메서드들은 인수로 전달되는 값들을 암묵적으로 타입변환하지 않는다
      빌트인 전역함수들과 이름이 겹칠 수도 있는데 헷갈리지 말 것

  *** Number래퍼객체의 메서드들을 숫자리터럴 뒤에 쓰는 경우 
      ex) 77.toExponetial => 77 다음에 오는 '.'이 부동 소수점인지 접근연산자인지 구분이 안된다.
         => (77).toExponential //"7.7e+1"  처럼 그룹연산자를 사용할 것을 권장


52. 심벌 값은 Symbol()을 호출하여 생성. (new와 함께 쓰지 않음)
     => 다른 값과 중복x
     ==> 문자열을 인수로 전달 받을 수 있는데 이는 설명? 디버깅의 역할만 할뿐 값 자체에는 영향x

    ex) const symbol1 = Symbol('test_key1');
	const symbol2 = Symbol('test_key1');

      clg(symbol1 === symbol2); //false

53. 심벌 값은 boolean형으로는 암묵적 타입변환이 이루어지지만
    '숫자', '문자열' 타입으로는 암묵적 형변환x


54.  Symbol함수를 통해 생성한 심벌 값은 호출될 때마다 유일무이한 값을 생성
      => but, 접근할 수 있는(검색할 수 있는) 키를 지정 못함
      ==> Symbol()로만 생성한 심벌 값은 전역 심벌 레지스트리에 등록되지 않는다

55. 따라서 Symbol.for()메서드를 사용
    : 전역 심벌 레지스트리에 '인자로 받은 값'이 키로 존재하지 않으면 새롭게 생성해서 등록
       + 존재한다면 기존에 있던 심벌값 반환

56. 심벌 값을 프로퍼티 키로 사용하면 
     : for...in문, Object.keys, Object.getOwnPropertyNames()에 검색x
   ==> 외부에 노출x. 은닉
   ===> Object.getOwnPropertySymbols()로는 검색 가능


57. 심벌은 중복되지 않는 값을 생성함으로
    기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해 사용한다고 한다.
    (하위 호환성을 위해)

***
58. 이터레이션 프로토콜 
    1) 이터러블 프로토콜
    2) 이터레이터 프로토콜


58-1) 이터러블
     : 이터러블 프로토콜을 준수하는 객체 
      =>  자바스크립트에서 제공하는 빌트인 심벌 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 구현했거나
          프로토타입 체인을 통해 상속받은 객체


58-2) 이터레이터 
    : 이터레이터 프로토콜을 준수하는 객체(이게 뭔 말 장난...)
      => Symbol.iterator 메서드를 호출하면 이터레이터를 반환하고
      ==> 이터레이터는 next메서드를 가진다
      ===> next메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 가지는
           이터레이터 리절트 객체가 반환된다.
	  
      ex)  const arr =  [1,2,3]; //이터러블 객체
             //이터러블객체 arr에 Symbol.iterator라는 프로퍼티명으로 접근 후 메서드 실행

	    clg(arr[Symbol.iterator]().next());   //{value:1, done:false}
	    clg(arr[Symbol.iterator]().next());   //{value:2, done:false}
	    clg(arr[Symbol.iterator]().next());   //{value:3, done:false}
	    clg(arr[Symbol.iterator]().next());   //{value:undefined, done:true}

      ※ 즉 이터러블 객체를 순회하기 위한 포인터 역할을 한다.

<1/6>

59. 스프레드 연산자 ... 의 결과는 값x
    =>변수에 할당 불가

    (스프레드문법) : 이터러블 객체에만 사용 가능 (유사배열 객체는 불가)   <--->    (Rest 파라미터) : 인수들의 목록을 배열 형태로 '묶는다'
	          이터러블 객체를 '펼쳐서' 개별적인 값의 목록으로

      1) 함수 호출문의 인수 목록 
      2) 배열 리터럴의 요소 목록
      3) 객체 리터럴의 프로퍼티 목록


60. 구조분해할당(디스트럭처링) => 구조화된 배열 혹은 이터러블 객체를 파괴해 1개 이상의 변수에 개별적으로 할당 (이터러블 객체에만 사용 가능)
                            //필요한 요소만 추출하여 값을 할당해야 할 때 주로 사용

                            할당 기준은 순서(인덱스)
     	                    변수의 개수와 이터러블의 요소 개수가 일치할 필요는 없음
                            ex)  const [a, b] = [1];   // a=1, b=undefined
                                 const[c, d] = [1,2,3]   //c=1, d=2
                                 const[ e, ,f] = [1,2,3]   //e =1, f=3


61. Set : 배열과 비슷해보이지만 수학적 집합에 가까움
          => 중복x, 인덱스 접근x, 순서x 

            .add() : 요소추가
	    .size() : 길이
            .has() : 요소 보유 여부
            .delete() : 요소 삭제(인수로 요소값을 받음)
	    .clear() : 모든 요소 삭제
	   

62. Map : 키와 값이 쌍으로 이루어졌다는 점에서 객체와 비슷해보이지만 다른 점이 있음
           1) 키로 모든 값이 올 수 있다 (객체는 문자열 혹은 심벌 값밖에 못 옴)
           2) 이터러블이다(일반객체는 Symbol.iterator를 프로퍼티이름으로 하는 메서드를 구현하기 이전엔 이터러블이 아님)

        *반드시 키와 값 쌍으로 이루어진 요소가 인수로 전달되어 생성되어야 함
       ex)   const map1 = new Map([['key1','value1'],['key2','value2']]);
             const map2 = new Map([['key3','value3']]);


            .set('key1', 'value1') : 요소 추가
	    .size(): 요소 개수 확인
	    .get('key1') : 요소 취득  //키로 접근
            .has()
            .delete()
            .clear()
            .keys() : 호출한 Map 객체의 키를 값으로 가지는 이터러블 객체 반환
            .values() : 호출한 Map객체의 값을 값으로 가지는 이터러블 객체 반환
            .entries() : 호출한 Map 객체의 키와 값을 가지는 (  [ , ]쌍으로  ) 이터러블 객체 반환


<1/8>

63. 클라이언트단에서 http 요청
     => html, css, js, img 등 리소스를 받음
     ==> html 파싱 : DOM 트리 생성 (생성 중 <link> 혹은 <style> , <script> 태그 만나서 외부 css js 호출하면 일시정지)
     ===> css 파싱 : CSSOM트리 생성 (만들고 다시 나가서 html 이어서 해석 및 DOM 생서 재개)

     ====> DOM + CSSOM 합쳐서 랜더 트리 생성(화면에 렌더링 되지 않는 노드는 표시x)

     ** 레이아웃이 추후에 변경되면 ex) 1) js DOM API 사용(노드 동적 추가 및 삭제)
				2) 뷰포트에 따른 가변형
				3) 레이아웃 변경 ex) margin, padding, display, position 등

	=>리렌더링 발생 :  DOM, CSSOM 변경(리플로우) + 다시 렌더 트리로 결합(리페인팅) 


     +> js 파싱 : css파싱 과정처럼  AST(추상구문트리 생성)  => 인터프리터가 실행할 수 있는 바이트코드 변환 및 실행
     =====> DOM API 혹은 		


64. DOM트리를 구성하는 노드들 역시 js의 객체이기 때문에 (브라우저에서 제공하는 호스트 객체)
    =>프로토타입에 의한 상속구조를 가짐 + DOM API를 통해 조작이 가능하다


65. 복수의 요소를 취득하는 .getElementByClassName(), .getElementsByTagName()은 
    => '콜렉션객체' (유사배열+이터러블)을 반환함
    ==> 이 콜렉션 객체는 '실시간'반영 => 반복문을 돌던 도중 변경이 일어나면 바로 반영되니 주의

    **그래서 콜렉션 객체를 배열로 한번 변환해서 사용하는 것이 간단함  => [...콜렉션객체] 혹은 Array.from()


66. 마찬가지로 복수의 요소를 취득하는  .querySelectorAll()은 
    => '노드리스트'를 반환
    ===> 기본적으로 'non-live'라서 콜렉션객체처럼 실시간 반영x


67. 여러가지 DOM 조작 API

- 요소 내 텍스트노드 조작
   1) .innerHtml() :  html마크업 포함해서 반환 근데 파싱o 
   2) .textContent() : html마크업 안 가져옴. 파싱x  선택된 요소의 하위 텍스트까지 전부 다 긁어옴 숨겨진 것까지 (텍스트만, 마크업x)
   3) .nodeValue() :  요소노드.nodeValue()는 null, 텍스트요소.nodeValue()에서 원하는 텍스트가 나옴
                     요소.firstChild(텍스트노드).nodeValue()처럼 사용

   4) .innerText() : textContent()와 비슷. 텍스트만 가져오는데 css에 순종적이라 숨겨진 건 안 가져옴
                     +렌더링되는 텍스트만 가져옴
 


- .insertAdajacentHtml()
  => 요소 

- 이미 존재하는 요소를 다시 append해주면 이동된다??(맞음?)
- .insertBefore(newNode, childNonde) : append, prepend 말고 2번쨰 인수로 지정한 노드 앞에 요소 추가

-.cloneNode() 요소 복사 
  (인수로 true를 전달받으면 깊은 복사(자손까지 다 복사)  || 기본값 false 얕은 복사 (자손노드 복사x)

- .replaceNode() 요소 교체
- .removeChild() 요소 삭제

